# A Functorial Semantics for Compile-Time Reference Graphs

### Abstract
We present a categorical semantics for Marchâ€™s compile-time reference-graph
memory model.  Each word (or thunk) in March is interpreted as a morphism
between stack types, and each such morphism induces a finite directed graph
representing heap allocation and reference flow.  The compiler thereby defines
a strong symmetric monoidal functor from the syntactic category of words to a
semantic category of reference graphs.  Composition in syntax corresponds to
graph pushout (stitching), and liveness analysis is interpreted as a counit
natural transformation selecting the reachable subgraph.  This construction
gives a concise mathematical account of compile-time memory safety and
deterministic deallocation.

---

## 1. The Word Category ğ‘¾á´Ê€á´…

Let **Word** denote the free *symmetric monoidal category* generated by the
core March primitives.

- **Objects**: Stack signatures \( A_1 \otimes \dots \otimes A_n \).
- **Morphisms**: Words or thunks \( f : X \to Y \) with typed stack effects.
- **Composition**: Sequential concatenation of words.
- **Monoidal product**: Stack concatenation \( X \otimes Y \).

This category captures the pure syntactic structure of March programs.

---

## 2. The Reference-Graph Category ğ‘¹á´‡êœ°GÊ€á´€á´˜Êœ

Let **RefGraph** denote the category of finite directed graphs with boundary
ports representing live input and output references.

- **Objects:** Graphs \( G = (V, E, \mathrm{in}, \mathrm{out}) \)  
  where \(V\) are heap nodes, \(E \subseteq V\times V\) are reference edges,
  and \(\mathrm{in},\mathrm{out}\subseteq V\) mark boundary nodes.

- **Morphisms:** Port-preserving graph homomorphisms \(h:G\to H\).

- **Composition:** Pushout along matched ports
  \( G_2 \circ G_1 = G_2 \;\square\; G_1 \),  
  merging outputs of \(G_1\) with inputs of \(G_2\).

- **Monoidal product:** Disjoint union \( G \otimes H = G \sqcup H \).

**RefGraph** is therefore a *symmetric monoidal category* whose morphisms
compose by structural gluing.

---

## 3. The Functor

The March compiler induces a *strong symmetric monoidal functor*

\[
\mathcal{G} : \mathbf{Word} \longrightarrow \mathbf{RefGraph}
\]

defined on generators by mapping each primitive word to its compile-time
mini-graph and extending to composite words by functoriality:

\[
\begin{aligned}
\mathcal{G}(g \circ f) &= \mathcal{G}(g) \;\square\; \mathcal{G}(f), \\
\mathcal{G}(f \otimes g) &= \mathcal{G}(f) \sqcup \mathcal{G}(g).
\end{aligned}
\]

Intuitively, \( \mathcal{G} \) translates program syntax into a concrete graph
of object relationships; sequential composition becomes graph stitching, and
parallel composition becomes disjoint union.

---

## 4. Liveness as a Natural Transformation

Define a **reachability functor**

\[
R : \mathbf{RefGraph} \longrightarrow \mathbf{RefGraph}
\]
that maps each graph \(G\) to its reachable subgraph
\(R(G)=\mathrm{Reach}(G,\mathrm{out}(G))\).

There exists a natural transformation  
\(\varepsilon : \mathrm{Id}_{\mathbf{RefGraph}} \Rightarrow R\)  
such that each component
\(\varepsilon_G : G \to R(G)\) deletes all unreachable nodes and edges.

This transformation expresses **liveness**:
nodes not in the image of \(\varepsilon_G\) are provably dead and can be
deallocated at compile time.

---

## 5. Theorem â€” Functorial Liveness Preservation

**Statement.**  
For all composable words \( f : X \to Y \) and \( g : Y \to Z \),

\[
R(\mathcal{G}(g \circ f))
  \;=\;
R(\mathcal{G}(g)) \;\square\; R(\mathcal{G}(f)).
\]

**Proof Sketch.**  
Because \( \mathcal{G} \) preserves pushouts by definition,
and reachability \(R\) commutes with pushout along live ports,
the reachable subgraph of the composite equals the pushout of the reachable
subgraphs.  Hence deallocation performed after composing words is equivalent to
deallocation performed within each word before compositionâ€”liveness is
*functorially preserved*.

---

## 6. Interpretation

- **Allocation** corresponds to the unit \( I \to A \).  
- **Duplication** corresponds to comultiplication \( A \to A \otimes A \).  
- **Drop / Free** corresponds to the counit \( A \to I \).  
- **Composition** corresponds to resource flow through morphisms.  
- **Liveness** corresponds to the counit transformation \( \varepsilon \).  

Together, \( (\mathbf{Word}, \mathbf{RefGraph}, \mathcal{G}, R, \varepsilon) \)
form a concise categorical model of Marchâ€™s compile-time memory semantics.

---

### Corollary
Because \( \mathcal{G} \) is strong monoidal and \(R\) is natural,
compile-time memory management in March is **deterministic and compositional**:
each wordâ€™s local deallocations compose without altering the global heap
behavior.

---

### References
- Benton, N., Bierman, G., et al. *Linear Logic and Linear Type Systems.*
- Selinger, P. *A Survey of Graphical Languages for Monoidal Categories.*
- Mac Lane, S. *Categories for the Working Mathematician.*



## Appendix: Diagrammatic Semantics

The functorial model of compile-time reference graphs can be represented
**diagrammatically** using string diagrams of a symmetric monoidal category.
Each wire represents a live reference; each box represents a word or thunk;
composition corresponds to joining outputs to inputs.

### 1. Morphisms as String Diagrams

A word \( f : X \to Y \) is drawn as:

```
X â”€â”€â–¶[ f ]â”€â”€â–¶ Y
```

and composition \( g \circ f \) as:

```
X â”€â”€â–¶[ f ]â”€â”€â–¶ Y â”€â”€â–¶[ g ]â”€â”€â–¶ Z
```

The functor \(\mathcal{G}\) maps this syntactic composition
to *graphical composition* in **RefGraph** via pushout:

```
   G(f):  Xâ”€â”€â–¶â—Aâ”€â”€â–¶â—Bâ”€â”€â–¶Y
   G(g):  Yâ”€â”€â–¶â—Câ”€â”€â–¶â—Dâ”€â”€â–¶Z
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Pushout: Xâ”€â”€â–¶â—Aâ”€â”€â–¶â—B=Y=â—Câ”€â”€â–¶â—Dâ”€â”€â–¶Z
```

Here, \(Y\) acts as the shared boundary of the pushout,
corresponding to the run-time connection of the two words.

---

### 2. Allocation and Free as Units and Counits

Allocation (`alloc`) and deallocation (`free`) correspond to
the unit and counit morphisms of the linear resource category:

```
      alloc : I â”€â”€â–¶[ Î· ]â”€â”€â–¶ A
      free  : A â”€â”€â–¶[ Îµ ]â”€â”€â–¶ I
```

Graphically, allocating introduces a new wire (heap object),
and freeing terminates a wire.  
All other primitives are expressed as compositions of these
and structural rearrangements (dup, drop, swap).

---

### 3. Liveness as Reachability

After composition, the reachable subgraph \(R(G)\) is visualized by
**tracing** only the wires that connect to outputs (roots).

Example:

```
Before liveness:

X â”€â”€â–¶[ f ]â”€â”€â–¶ â—A â”€â”€â–¶ â—B â”€â”€â–¶[ g ]â”€â”€â–¶ Z
                 â”‚
                 â–¼
                 â—C   (unreachable)

After liveness (ÎµG applied):

X â”€â”€â–¶[ f ]â”€â”€â–¶ â—A â”€â”€â–¶ â—B â”€â”€â–¶[ g ]â”€â”€â–¶ Z
```

The node `â—C` is removed by the counit transformation
\(\varepsilon_G : G \to R(G)\),
which deletes unreachable subgraphs.

---

### 4. Graphical Law of Functorial Liveness Preservation

For composable words \(f : X \to Y\) and \(g : Y \to Z\):

```
(1) Separate compilation:

Xâ”€â”€â–¶[ f ]â”€â”€â–¶Yâ”€â”€â–¶[ g ]â”€â”€â–¶Z
     ÎµGf â”‚           â”‚ ÎµGg
         â–¼           â–¼
     Reach(f)     Reach(g)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Pushout: Reach(g) â§º Reach(f)

(2) Whole-program compilation:

Xâ”€â”€â–¶[ f ; g ]â”€â”€â–¶Z
     â”‚
     â–¼
     Reach(f;g)
```

Functoriality of \(\mathcal{G}\) ensures:

\[
R(\mathcal{G}(g \circ f))
  \;=\;
R(\mathcal{G}(g)) \;\square\; R(\mathcal{G}(f))
\]

so deallocation is compositionally stable.

---

### 5. Intuitive Summary

- **Wires** = live references (RefNodes)  
- **Boxes** = words (heap transformers)  
- **Joining wires** = word composition (pushout)  
- **Dead wires** = freed objects (counit)  
- **Erasure of dead wires** = liveness analysis

Thus Marchâ€™s compile-time reference system admits
a *graphical calculus* identical to that of **linear resource flow**:
wires represent ownership, boxes represent transformations,
and eliminating disconnected wires corresponds exactly to deterministic
compile-time deallocation.


